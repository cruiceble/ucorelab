Task1:
　　实现过程：
　　	首先判断开头:如果不满一个block就用buf_io的操作；
　　	然后处理中间：每个block用blk_io的操作；
　　	最后判断结尾:如果不满一个block用buf_io操作
		ret返回是否操作成功，alen返回操作成功的长度。
		在实现时候一开始和同学讨论误认为ret是返回alen导致有问题，后来改正。
	
	问题：设置三个系统调用来负责管道的新建，读入和输出。管道内维护读指针、写指针、信号量和数据区。缓冲区满时写指针在读指针前一格，缓冲区空时两个指针重合。信号量保证有一个进程在写数据的互斥以及相应的进程睡眠唤醒。

Task2：
　　实现过程：
　　	lab8的load_icode只有文件和句柄而不是lab7原来的binary文件数据，
所以要修改load_icode中和binary有关的地方，按照它的offset和需要的东西来从文件读入相应的数据。然后在堆栈的USTACKTOP建立main的参数堆栈存放argv的数据以及指针还有argc，最后返回新的栈顶位置。

　　问题：
　　	硬链接：新建inode的时候取disk_inode为目标的disk_inode，并将这个inode引用计数+1，删除的时候引用计数-1。
　　	软链接: 软链接相当于"快捷方式"。可以在创建软链接时分配创建一个新的文件（这时创建了一个新的inode），并把old_path的内容存放到文件的内容中去。给该文件保存在磁盘上时disk_inode类型为SFS_TYPE_LINK，再完善对于该类型inode的操作即可。unlink时类似于删除一个普通的文件。

知识点：
	理论课中的冗余磁盘阵列RAID没有在实验中实现。
	原理课对于VFS的inode和SFS的inode没有讲清联系区别，也没有涉及新的load_icode的实现。


